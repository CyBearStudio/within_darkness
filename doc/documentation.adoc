:imagedir: img/

= Documentation for developers

This is the technical documentation for developers. One can find here every necessary info on the code that has been written and the one to write.

---

== Task list

* [x] main function

* [x] Logger class

* [ ] Game class

* [ ] Options class

* [ ] Screen class



== Program entry

link:base/main.adoc[main.adoc]

=== Files:

* link:../src/main.cpp[src/main.cpp]

=== The main function:

* creates a new *Logger* object

* creates a new *Game* object with the new *Logger* object

* intializes the Game

* runs the Game

.main function
[source, C++]
----
int main()
{
    logger = new Logger();
    game = new Game(logger);

    game.init();
    game.run();
}
----



== Logger

link:base/logger.adoc[logger.adoc]

=== Files:

* link:../include/Logger.h[include/Logger.h]

* link:../src/Logger.cpp[src/Logger.cpp]

=== The Logger class:

* is responsible for logging the console output into a txt file

* the log(String str) method append a new line to the log file and displays it in the console

* the log file is latestlog.txt at the root of the program

.Logger class
[source, C++]
----
class Logger
{
public:
    void log(String str);
    
private:
    FileType logfile;
};

void Logger::log(String str)
{
    logfile.append(str);
    std::cout<<str<<std::endl;
}
----



== Game

link:base/game.adoc[game.adoc]

=== Files:

* link:../include/Game.h[include/Game.h]

* link:../src/Game.cpp[src/Game.cpp]

=== The Game class:

* is the master class of the game.

* initializes the game by loading user settings

* handles the game loop

* handles the different screens

* passes the inputs

* updates the screens

* renders the screens

.Game class
[source, C++]
----
class Game
{
public:
    Game();
    void init();
    void run();

private:
    void processEvents();
    void update();
    void render();

private:
    sf::RenderWindow mWindow;
};
----



== Options

link:base/options.adoc[options.adoc]

=== Files:

* link:../include/Options.h[include/Options.h]

* link:../src/Options.cpp[src/Options.cpp]

=== The Options class:

* stores the options variables

* creates default settings on construction

* can be linked to a file with load()

* can store settings to the link file with save()

.Options class
[source, C++]
----
class Options
{
public:
    Options();
    void load();
    void save();

private:
    FileType optionsFile;
    Type1 mOption1;
    Type2 mOption2;
    ...
}
----



== Screen

link:screens/screen.adoc[screen.adoc]

=== Files:

* link:../include/Screens/Screen.h[include/Screens/Screen.h]

* link:../src/Screens/Screen.cpp[include/Screens/Screen.cpp]

=== The Screen class:

* is a virtual class

* is the base class to create specific screens

* can process events, update and render through the corresponding methods

* can block further event processing, updates or renders or not (depend on screen type and cannot be changed)

.Screen class
[source, C++]
----
class Screen
{
public:
    Screen();
    virtual void processEvents();
    virtual void update();
    virtual void render();

private:
    const bool blockEvents;
    const bool blockUpdate;
    const bool blockRender;
}
----



== Resource holding

link:base/resourceHolder.adoc[resourceHolder.adoc]

=== Files:

* link:../include/ResourceHolder.h[include/ResourceHolder.h]

* link:../src/ResourceHolder.cpp[src/ResourceHolder.cpp]

=== The ResourceHolder class:

* is a template class

* hold resources (textures, audio, etc ...) in a map

* can load a resource with a specific identifier

* provide access to the resource using the identifier

.ResourceHolder class
[source, C++]
----
template <typename Resource, typename Identifier>
class ResourceHolder
{
public:
    void load(Identifier id, std::string filename);
    const Resource& get(Identifier id) const;

private:
    std::map<Identifier, std::unique_ptr<Resource>> mResourceMap;
}
----


